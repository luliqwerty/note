
洛书拥有良好的 C/C++ 交互性，洛书的解释器由 C 语言( c99 )进行实现，并通过 API 接口，实现与 C 语言的互操作与数据交换（在我目前的理解下不就是调用C库函数嘛）（更正：不是为了调用C库函数，而是为了在洛书脚本语言中使用C语言传递的参数然后生成构造函数将其实现）。洛书以模块为单位管理C拓展，支持通过编写构造器函数与将脚本打包进 C 程序的方式，来实现功能的拓展。但是，手动编写的方式在实际开发中存在一定的缺陷：一、手动编写构造器函数思路复杂、效率低下、出错率高；二、直接打包脚本，脚本中注释与空行等无用信息造成性能损失。

因此，洛书需要一个模块预编译工具，可以通过脚本文件，自动化生成构造器函数、绑定 C 函数、并将脚本编译为紧凑的字节码文件。

二、项目目标

开发一个针对 洛书(Losu) 编程语言的预编译工具，支持将洛书脚本编写的模块接口文件，编译出包含构造器函数、C-API 接口、脚本字节码的C文件，提高实际项目中拓展模块的制作效率。
在实现基本功能后，将其集成到洛书的包管理系统中，让用户可以通过洛书内置的包管理器实现快速安装。
三、项目需求

字节码部分需求
设计一种简单可行的字节码结构，用更高的信息密度，储存源码中有价值的信息。字节码需要储存的信息有：变量名、字面量、常量、实际行号、作用域等运行相关信息。
设计预编译器，支持将洛书的源代码编译到该字节码，并支持文本与 C 语言数组两种导出模式。
构造器与C接口部分需求
可以识别出需要从C语言中获取字面量，并根据其名称，生成对应的 C 语言赋值语句；
可以识别出需要从C语言中实现的函数，并根据函数声明，生成对应的 C 接口；
可以识别出需要从C语言中获取的对象，并根据对象成员，生成对应的 C 构造器函数；
可以识别出 类(class) ，并根据类的结构，生成对应的 C 语言构造器函数与其成员函数的 C 接口。
四、项目阶段和验证

该功能可分为多个阶段开发：

第一阶段，设计脚本声明文件格式、字节码转换标准与 C-API 与构造器函数生成规范。其中，脚本声明文件格式必须采用 洛书编程语言语法或其子集，C-API的命名与构造器函数的实现必须以人类易读的方式呈现。
第二阶段，完成字节码部分的需求，实现脚本源代码到字节码的编译功能。最终可以在示例代码上通过相关测试验证。
第三阶段，完成构造器与C接口部分的需求，实现脚本的函数、对象、类等数据结构到 C 语言构造器与 API 函数的自动绑定。最终可以在示例代码上通过相关测试验证。
第四阶段，将其集成到洛书的包管理系统之中。
最终以命令行工具的形式交付至洛书的包管理系统，实现通过命令行调用该工具对洛书模块进行预编译的效果。


解决方案：

就用一个结构体存储所有的字节码文件

字节码既是用操作数代替操作码

操作码		操作数	line（行号）
TOKEN_ADD	1	1	把TOKEN_ADD这一操作存储时只存1，然后判断，当 opcode == 1 时就把两个数加起来。



洛书的运行机制是将源代码编译到一种类似汇编语言的字节码指令，我们不妨将它称作 byte-0，这种字节码的特点包括：
（1）存放于内存中；
（2）大小端敏感；
（3）不包含具体数据信息。
这使得基于byte-0设计可导出的字节码文件可能会面临一些困难：
（1）字节码生成与运行平台的大小端问题；
（2）需要额外设计数据导出格式：仅仅导出byte-0到文件中是不足以运行一个洛书程序的。以最简单的 'hello,world' 为例，字符串 'hello,world' 与 `print` 函数的具体内容存放于虚拟机的相应储存结构中，需要被一并导出。因此，为了降低实现难度，任务提出可以重新设计一套字节码标准（不妨称作 IR-0），IR-0 并不强制要求被设计为类汇编格式，它可以保留高级语法结构，甚至仅仅只是在词法上进行精简。它的首要任务并不是为了提高脚本加载速度，而是节约脚本打包所占用的体积。当然，如果有足够的能力与精力，也欢迎设计更高效更精简的类汇编字节码。