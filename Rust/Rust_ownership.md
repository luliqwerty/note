Rust 所有权出现的原因是为了能够管理分配在 heap 上的内存

## 原理分析

Rust的所有权规则有以下3条:

- Rust中的每个值都有一个所有者
- 一个值在同一时刻只能有一个所有者
- 当所有者离开作用域时，其拥有的值将被丢弃

可能发生所有权不唯一的情况：

1. 一个变量赋值给另一个变量
2. 变量作为参数传递给另一个函数调用
3. 返回值从函数返回

## 解决方案

Rust 主要使用 Copy 和 Move 这两个语义来保证单一所有权。

基本数据类型都默认实现了 copy trait 所以复制之后还能再次使用，例如 i32 f32 tuple 元组

复杂类型例如 String 没有实现 copy trait ，所以赋值之后原来的变量被废弃了。实现了 copy trait 旧的变量在复制之后还能使用。



一个值不能同时被多个变量借用为可变的变量，但可以有多个不可变变量。在使用过被引用过后的变量之后可再次被借用为可变变量 `&mut` 